#set syntax = strict;
require "../../../core/libs/interfaceLibrary.mnd";

linked berthaBullet = processor1;

noinit shotEta;
noinit buttonCooldown, berthaCooldown, targetTimeout, aimTimeout;
noinit angle, angleDiff, angleTarget, angleTime;
noinit berthaDisplayX, berthaDisplayY, displayTime;
noinit lockedTargetX, lockedTargetY, lastTargetX, lastTargetY,autoReady;
noinit volatile shotTrigger, syncedBlast, panelOpened, aimingPlayer, targetX, targetY, autoMode;
noinit vault, ammo;


var shotSpeed = 120; //Tiles per second
var ammoCost = 30;

param berthaX = 325;
param berthaY = 353;

var playerTeam = @sharded;
var titleColor = "[orange]";
var subtitleColor = "[gold]";
var highlightColor = "[blue]";
var textColor = "[white]";

var id = getId(out id);
var idBertha1 = id;
var idBertha2 = id + 1;
var idShadow = id + 2;
var idLeg1 = id + 3;
var idLeg2 = id + 4;
var idLeg3 = id + 5;
var idLeg4 = id + 6;
var idAim1 = id + 7;
var idAim2 = id + 8;
var idAim3 = id + 9;
var idPanelButton = id + 10;
var idPanel = id + 11;
var idVault = id + 12;

var clientState = 0;

begin

    setrate(1000);
    setmarker(:remove, idBertha1);
    setmarker(:remove, idBertha2);
    setmarker(:remove, idShadow);
    setmarker(:remove, idLeg1);
    setmarker(:remove, idLeg2);
    setmarker(:remove, idLeg3);
    setmarker(:remove, idLeg4);
    //setblock(:block, @vault, berthaX, berthaY, playerTeam, 0);

    if @server then do
        server();
        client();
    while true; end;

    if @client then do
        client();
    while true; end;
end;

void server()

    if @client then end(); end;

    var panelButton = mapButton(berthaX, berthaY - 6, 2, 2, playerTeam);
    if panelButton == 2 && @tick > buttonCooldown then
        buttonCooldown = @tick + 60;
        panelOpened = panelOpened == 0 ? 1 : 0;
    end;

    if panelOpened then
        if aimingPlayer == null then
            var targetButton = mapButton(berthaX - 2.2, berthaY - 11.6, 3, 1, playerTeam, out aimingPlayer);
            if targetButton == 2 then
                buttonCooldown = @tick + 60;
                targetTimeout = @tick + 600;
                autoMode = 0;
            end;
            var autoButton = mapButton(berthaX + 2.15, berthaY - 11.6, 3, 1, playerTeam);
            if autoButton == 2 then
                 buttonCooldown = @tick + 60;
                 autoMode = 1;
            end;
        else

            targetX = aimingPlayer.sensor(@shootX);
            targetY = aimingPlayer.sensor(@shootY);

            if lastTargetX != targetX && lastTargetY != targetY then
                targetTimeout = @tick + 600;
            end;

            lastTargetX = targetX;
            lastTargetY = targetY;

            if @tick > targetTimeout then
                aimingPlayer = null;
                targetX = null;
                targetY = null;
            end;

            if aimingPlayer.sensor(@shooting) && @tick > buttonCooldown then
                aimingPlayer = null;
            end;
        end;
    end;

    if autoMode && !autoReady then
        var coreCount = fetch(:coreCount, @blue);
        var randCore = floor(rand(coreCount));
        var coreTarget = fetch(:core, @blue, randCore);
        targetX = coreTarget.sensor(@x);
        targetY = coreTarget.sensor(@y);
        autoReady = 1;
    end;

    updateRotation();

    vault = getblock(:building, berthaX, berthaY);
    if vault != @vault then
        vault == null;

    end;

    var readyToShoot = abs(angleDiff) < 1 &&
                       targetX != null &&
                       vault.sensor(@blast-compound) > ammoCost &&
                       @second > berthaCooldown;

    if readyToShoot then
        shotTrigger = 1;
        sync(shotTrigger);
        vault.setprop(@blast-compound, vault.sensor(@blast-compound) - ammoCost);
        lockedTargetX = targetX;
        lockedTargetY = targetY;
        shotEta = @second + len(berthaX - targetX, berthaY - targetY) / shotSpeed;
        berthaCooldown = @second + 5;
    end;

    if @second > shotEta && shotEta != null then

        var blocked = 0;

        for var i in 0 .. fetch(:buildCount, @sharded, @world-processor) do
            var processor = fetch(:build, @sharded, i, @world-processor);
            if processor.read("structureId") == "floodBarrier" then

                var barrierX = processor.read("blockX");
                var barrierY = processor.read("blockY");
                var barrierRadius = processor.read("radius");

                if len(lockedTargetX - barrierX, lockedTargetY - barrierY) < barrierRadius then
                    blocked = 1;
                    break;
                end;

            end;
        end;

        if !blocked then
            explosion(playerTeam, lockedTargetX, lockedTargetY, 12, 500, 1, 1, 1, true);
            shotEta = null;
            autoReady = 0;
        end;
    end;

    syncedBlast = vault.sensor(@blast-compound);
    sync(syncedBlast);
    sync(panelOpened);
    sync(aimingPlayer);
    sync(targetX);
    sync(targetY);
    sync(autoMode);

end;

void client()

    if !clientState then
        initializeClient();
        clientState = 1;
    end;

    var panelButton = mapButton(berthaX, berthaY - 6, 2, 2, playerTeam);
    print(panelButton != 0 ? highlightColor : textColor);
    print("[  ]");

    makemarker(:text, idPanelButton, 0, 0, false);
    setmarker(:fontSize, idPanelButton, 1.5);
    setmarker(:flushText, idPanelButton, 0);
    setmarker(:pos, idPanelButton, berthaX, berthaY - 6);

    if panelOpened then

        print(titleColor, " Big Bertha \n\n");

        print("Target:\n\n");

        var targetButton = mapButton(berthaX - 2.2, berthaY - 11.6, 3, 1, playerTeam);
        var autoButton = mapButton(berthaX + 2.15, berthaY - 11.6, 3, 1, playerTeam);

        print(targetButton != 0 ? highlightColor : subtitleColor);
        print("[ Set ]", subtitleColor, " / ");
        print(autoButton != 0 ? highlightColor : subtitleColor);
        print("[ Auto ]\n\n");

        if aimingPlayer == null && targetX == null then
            print(textColor, "Target not set.");
        end;
        if targetX != null then
             print(textColor, "Target:[red] ", ceil(targetX), ", ", ceil(targetY), "\n");
         end;
        if aimingPlayer != null then
            print(textColor, aimingPlayer.sensor(@name), " is aiming.");
            aimTimeout = @tick + 60;
        else if autoMode then
            print(textColor, "Auto aiming.");
        end; end;

        print("\n\n");
        vault = getblock(:building, berthaX, berthaY);
        if vault.sensor(@type) != @vault then
            vault == null;
            print("[red] No vault detected!");
            makemarker(:shape, idVault, 0, 0, false);
            setmarker(:shape, idVault, 4, 0, 0);
            setmarker(:pos, idVault, berthaX, berthaY);
            setmarker(:radius, idVault, 2 * 8);
            setmarker(:rotation, idVault, 45);
            setmarker(:color, idVault, %ff636378);
        else
            resourceTooltip(vault, @blast-compound, ammoCost);
            setmarker(:remove, idVault);
        end;

        makemarker(:text, idPanel, 0, 0, false);
        setmarker(:fontSize, idPanel, 1.5);
        setmarker(:flushText, idPanel, 0);
        setmarker(:pos, idPanel, berthaX, berthaY - 8);

        if targetButton != 0 || aimingPlayer != null || @tick < aimTimeout then
            aimMarker();
        else
            setmarker(:remove ,idAim1);
            setmarker(:remove ,idAim2);
            setmarker(:remove ,idAim3);
        end;

    else setmarker(:remove, idPanel); end;

    updateRotation();
    updatePosition();

    setmarker(:rotation, idBertha1, angle + 90);
    setmarker(:rotation, idBertha2, angle + 90);
    setmarker(:pos, idBertha1, berthaDisplayX, berthaDisplayY);

    vault.setprop(@blast-compound, syncedBlast);

    if shotTrigger then
        shotTrigger = 0;
        berthaCooldown = @second + 5;

        berthaDisplayX = berthaX + cos(angleTarget) * 1.5;
        berthaDisplayY = berthaY + sin(angleTarget) * 1.5;

        var bulletX = berthaDisplayX + cos(angleTarget) * -4;
        var bulletY = berthaDisplayY + sin(angleTarget) * -4;

        playsound(:true, @sfx-bang, 1, 0.5, bulletX, bulletY, 1);
        effect(:smokeColor, bulletX, bulletY, angle + 180, %ff6363);
        effect(:smokeColor, bulletX, bulletY, angle + 195, %ff6363);
        effect(:smokeColor, bulletX, bulletY, angle + 165, %ff6363);

        berthaBullet.write(bulletX, ".bulletX");
        berthaBullet.write(bulletY, ".bulletY");
        berthaBullet.write(targetX, ".targetX");
        berthaBullet.write(targetY, ".targetY");
        berthaBullet.write(shotSpeed, ".shotSpeed");
        berthaBullet.write(angleTarget, ".angleTarget");
    end;

end;

void aimMarker()
    if targetX != null then
        var offSetX = berthaX - cos(angleTarget) * 7.5;
        var offSetY = berthaY - sin(angleTarget) * 7.5;

        makemarker(:line, idAim1, 0, 0, false);
        setmarker(:pos, idAim1, offSetX, offSetY);
        setmarker(:endPos, idAim1, targetX, targetY);
        setmarker(:drawLayer, idAim1, 100);
        setmarker(:stroke, idAim1, 2);
        setmarker(:color, idAim1, %ff6363);

        makemarker(:shape, idAim2, 0, 0, false);
        setmarker(:pos, idAim2, offSetX, offSetY);
        setmarker(:shape, idAim2, 4, 1, 0);
        setmarker(:drawLayer, idAim2, 100);
        setmarker(:color, idAim2, %ff6363);

        makemarker(:shape, idAim3, 0, 0, false);
        setmarker(:pos, idAim3, targetX, targetY);
        setmarker(:shape, idAim3, 4, 1, 0);
        setmarker(:drawLayer, idAim3, 100);
        setmarker(:color, idAim3, %ff6363);
    end;
end;

void initializeClient()

    berthaDisplayX = berthaX;
    berthaDisplayY = berthaY;

    makemarker(:texture, idBertha1, 0, 0, 0);
    makemarker(:texture, idBertha2, 0, 0, 0);
    makemarker(:texture, idShadow, 0, 0, 0);
    makemarker(:texture, idLeg1, 0, 0, 0);
    makemarker(:texture, idLeg2, 0, 0, 0);
    makemarker(:texture, idLeg3, 0, 0, 0);
    makemarker(:texture, idLeg4, 0, 0, 0);

    setmarker(:texture, idBertha1, 0, "titan-barrel-outline");
    setmarker(:texture, idBertha2, 0, "titan-outline");
    setmarker(:texture, idShadow, 0, "circle-shadow");
    setmarker(:texture, idLeg1, 0, "titan-side-l-outline");
    setmarker(:texture, idLeg2, 0, "titan-side-l-outline");
    setmarker(:texture, idLeg3, 0, "titan-side-r-outline");
    setmarker(:texture, idLeg4, 0, "titan-side-r-outline");

    setmarker(:textureSize, idBertha1, 3, 7);
    setmarker(:textureSize, idBertha2, 4, 8);
    setmarker(:textureSize, idShadow, 8, 8);
    setmarker(:textureSize, idLeg1, 6, 6);
    setmarker(:textureSize, idLeg2, 6, -6);
    setmarker(:textureSize, idLeg3, -6, 6);
    setmarker(:textureSize, idLeg4, -6, -6);

    setmarker(:rotation, idLeg1, 45);
    setmarker(:rotation, idLeg2, -45);
    setmarker(:rotation, idLeg3, -45);
    setmarker(:rotation, idLeg4, 45);

    setmarker(:color, idShadow, %000000a7);

    setmarker(:drawLayer, idBertha1, 55);
    setmarker(:drawLayer, idBertha2, 54.9);
    setmarker(:drawLayer, idShadow, 54);
    setmarker(:drawLayer, idLeg1, 54.1);
    setmarker(:drawLayer, idLeg2, 54.1);
    setmarker(:drawLayer, idLeg3, 54.1);
    setmarker(:drawLayer, idLeg4, 54.1);

    setmarker(:pos, idBertha1, berthaX, berthaY);
    setmarker(:pos, idBertha2, berthaX, berthaY);
    setmarker(:pos, idShadow, berthaX, berthaY-1);
    setmarker(:pos, idLeg1, berthaX - 3, berthaY);
    setmarker(:pos, idLeg2, berthaX - 3, berthaY - 0.5);
    setmarker(:pos, idLeg3, berthaX + 3, berthaY);
    setmarker(:pos, idLeg4, berthaX + 3, berthaY - 0.5);
end;

void updateRotation()

    if targetX != null then angleTarget = angle(berthaX - targetX, berthaY - targetY) % 360;
    else angleTarget = -90; end;

    angleDiff = (angleTarget - angle) % 360;
    if angleDiff > 180 then angleDiff -= 360; end;
    if angleDiff < -180 then angleDiff += 360; end;

    if angleDiff > 1 then
        angle += 45 * (@second - angleTime);
    end;
    if angleDiff < -1 then
        angle -= 45 * (@second - angleTime);
    end;
    angleTime = @second;

end;

void updatePosition()

var moveSpeed = 0.75;

    var dt = @second - displayTime;
    displayTime = @second;

    var dx = berthaX - berthaDisplayX;
    var dy = berthaY - berthaDisplayY;
    var dist = len(dx, dy);

    if dist > 0.01 then
        var step = moveSpeed * dt;
        if step > dist then
            berthaDisplayX = berthaX;
            berthaDisplayY = berthaY;
        else
            var dirX = dx / dist;
            var dirY = dy / dist;
            berthaDisplayX += dirX * step;
            berthaDisplayY += dirY * step;
        end;
    end;
end;