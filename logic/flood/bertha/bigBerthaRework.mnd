#set syntax = strict;
require "../../../logic/libs/interfaceLibrary.mnd";
require "../../../logic/libs/mathLibrary.mnd";
require "berthaBullet.mnd" remote processor1, processor2, processor3;

volatile processorId = "bertha";


param team = @sharded;
param berthaX = 50;
param berthaY = 50;

const ammoCost = 30;
const cooldown = 5;

// Stuff

noinit berthaBarrelX, berthaBarrelY, lastTargetX, lastTargetY, targetChosen, ready, berthaCooldown;
volatile noinit aimingPlayer, targetX, targetY;
volatile noinit blastSynced, shotTrigger;
volatile noinit surgeSynced, surgeBoosted;
volatile noinit phaseSynced, phaseBoosted;

noinit angle, targetAngle, angleDiff;

noinit vault;

// Buttons
noinit buttonCooldown;

volatile noinit manualAimTimeoutClient;
noinit manualAimButton, manualAimButtonPlayer, manualAimTimeout;

noinit autoAimButton;

// Time
noinit time, deltaTime, lastAim;

var id = getId(out id);
var idBertha1 = id;
var idBertha2 = id + 1;
var idShadow = id + 2;
var idLeg1 = id + 3;
var idLeg2 = id + 4;
var idLeg3 = id + 5;
var idLeg4 = id + 6;
var idManualAim = id + 7;
var idAutoAim = id + 8;
var idPanel = id + 9;
var idVault = id + 10;
var idInfo = id + 11;
var idInfo2 = id + 12;

var idAim1 = id + 30;
var idAim2 = id + 31;
var idAim3 = id + 32;
var idAimTimeout = id + 33;


var titleColor = "[orange]";
var subtitleColor = "[gold]";
var highlightColor = "[blue]";
var textColor = "[white]";

begin

    setrate(1000);
    for var i in id .. id + 1000 do
        setmarker(:remove, i);
    end;

    initialize();

    if @server then do
        if @client then end(); end;
        common();
        server();
        if @clientUnit != null then client(); end;
    while true; end;

    if @client then do
        common();
        client();
    while true; end;

end;

noinline void common()

    wait(1/60/60);
    deltaTime = @second - time;
    time = @second;

    vault = getblock(:building, berthaX, berthaY);
    if vault != @vault then vault == null; end;

    manualAimButton = mapButton(berthaX - 2, berthaY + 5.5, 3, 2, team, out manualAimButtonPlayer);
    autoAimButton = mapButton(berthaX + 2, berthaY + 5.5, 3, 2, team);

    var dx = berthaX - berthaBarrelX;
    var dy = berthaY - berthaBarrelY;
    var dist = len(dx, dy);

    if dist > 0.01 then
        var step =  deltaTime * 0.75;
        if step > dist then
            berthaBarrelX = berthaX;
            berthaBarrelY = berthaY;
        else
            var dirX = dx / dist;
            var dirY = dy / dist;
            berthaBarrelX += dirX * step;
            berthaBarrelY += dirY * step;
        end;
    end;

    // Angle

    var rotationSpeed = 360 / 5;

    if targetX != null then targetAngle = angle(berthaX - targetX, berthaY - targetY) % 360;
    else targetAngle = -90; end;

    if targetX != null then targetAngle = angle(berthaX - targetX, berthaY - targetY) % 360;
    else targetAngle = -90; end;

    angleDiff = (targetAngle - angle) % 360;
    if angleDiff > 180 then angleDiff -= 360; end;
    if angleDiff < -180 then angleDiff += 360; end;

    // Only update angle after recoil
    if dist < 0.01 || angle == null then
        if angleDiff > 1 then angle += deltaTime * rotationSpeed; end;
        if angleDiff < -1 then angle -= deltaTime * rotationSpeed; end;
        //Client angle will be faster than the server angle, this prevents the gun shooting early in the client
        if abs(angleDiff) > 1 && @second > berthaCooldown then
            berthaCooldown = @second + 0.2;
        end;
    end;

end;

noinline void server()

    if autoAimButton == 2 && @second > buttonCooldown then
        aimingPlayer = "auto";
        buttonCooldown = @second + 0.5;
    end;

    if manualAimButton == 2 && @second > buttonCooldown then
        aimingPlayer = manualAimButtonPlayer;
        buttonCooldown = @second + 0.5;
    end;

    if aimingPlayer != "auto" && aimingPlayer != null then

        lastTargetX = targetX;
        lastTargetY = targetY;
        targetX = aimingPlayer.sensor(@shootX);
        targetY = aimingPlayer.sensor(@shootY);

        if lastTargetX != targetX || lastTargetY != targetY then
            manualAimTimeout = @second + 10;
        end;

        if (aimingPlayer.sensor(@shooting) && @second > buttonCooldown) || @second > manualAimTimeout then
            aimingPlayer = null;
        end;

        //Can't sync manualAimTimeout because @second is desynced in the client, so we just sync the time left.
        manualAimTimeoutClient = manualAimTimeout - @second;
        sync(manualAimTimeoutClient);

    end;

    if aimingPlayer == "auto" && !targetChosen then
        var coreCount = fetch(:coreCount, @blue);
        var randCore = floor(rand(coreCount));
        var coreTarget = fetch(:core, @blue, randCore);
        targetX = coreTarget.sensor(@x);
        targetY = coreTarget.sensor(@y);
        targetChosen = true;
    end;

    ready = targetX != null && vault.sensor(@blast-compound) > ammoCost && @second > berthaCooldown;
    if ready then

        targetChosen = false;
        berthaCooldown = @second + cooldown;
        vault.setprop(@blast-compound, vault.sensor(@blast-compound) - ammoCost);
        blastSynced = vault.sensor(@blast-compound);
        sync(blastSynced);
        shotTrigger = 1;

        surgeBoosted = booster(@surge-alloy, ammoCost, ref surgeSynced);
        phaseBoosted = booster(@phase-fabric, ammoCost, ref phaseSynced);

        if surgeBoosted then
            tripleShot(berthaX, berthaY, phaseBoosted);
        else
            async(processor1.bullet(berthaX, berthaY, targetX, targetY, phaseBoosted));
        end;

        sync(surgeBoosted);
        sync(phaseBoosted);
        sync(shotTrigger);

    end;

    sync(targetX);
    sync(targetY);
    sync(aimingPlayer);

end;

noinline void client()

    if shotTrigger == 1 then

        vault.setprop(@blast-compound, blastSynced);
        vault.setprop(@surge-alloy, surgeSynced);
        vault.setprop(@phase-fabric, phaseSynced);

        berthaBarrelX = berthaX + cos(targetAngle) * 1.5;
        berthaBarrelY = berthaY + sin(targetAngle) * 1.5;

        var bulletX = berthaBarrelX + cos(targetAngle) * -4;
        var bulletY = berthaBarrelY + sin(targetAngle) * -4;

        playsound(:true, @sfx-bang, 1, 0.5, bulletX, bulletY, 1);
        effect(:smokeColor, bulletX, bulletY, angle + 180, %ff6363);
        effect(:smokeColor, bulletX, bulletY, angle + 195, %ff6363);
        effect(:smokeColor, bulletX, bulletY, angle + 165, %ff6363);

        if !surgeBoosted then
            async(processor1.bullet(bulletX, bulletY, targetX, targetY, phaseBoosted));
        else
            tripleShot(bulletX, bulletY, phaseBoosted);
        end;

        shotTrigger = 0;

    end;

    // Buttons

    if len(@clientUnit.sensor(@shootX) - berthaX, @clientUnit.sensor(@shootY) - berthaY) < 8 then

        print(manualAimButton != 0 ? highlightColor : textColor);
        print("[  ]");

        makemarker(:text, idManualAim, 0, 0, false);
        setmarker(:fontSize, idManualAim, 2.5);
        setmarker(:flushText, idManualAim, 0);
        setmarker(:pos, idManualAim, berthaX - 2, berthaY + 6.1);

        print(autoAimButton != 0 ? highlightColor : textColor);
        print("[  ]");

        makemarker(:text, idAutoAim, 0, 0, false);
        setmarker(:fontSize, idAutoAim, 2.5);
        setmarker(:flushText, idAutoAim, 0);
        setmarker(:pos, idAutoAim, berthaX + 2, berthaY + 6.1);

        if vault == null then

            print("[red]Vault Missing!");
            makemarker(:shapeText, idVault, 0, 0, false);
            setmarker(:radius,idVault, 16);
            setmarker(:rotation, idVault, 45);
            setmarker(:color, idVault, %ff6363);
            setmarker(:flushText, idVault, 0);
            setmarker(:pos, idVault, berthaX, berthaY);
            setmarker(:textHeight, idVault, 3);

        end;

        print(titleColor, " Big Bertha \n");
        print(subtitleColor, "Mode: ");
        print(aimingPlayer == "auto" ? "Auto" : "Manual");

        if vault != null then
            print("\n\nAmmo\n");
            resourceTooltip(vault, @blast-compound, ammoCost);
            print(subtitleColor, "\n\nBoosters\n");
            resourceTooltip(vault, @surge-alloy, ammoCost);
            print("\n");
            resourceTooltip(vault, @phase-fabric, ammoCost);
        end;

        makemarker(:text, idPanel, 0, 0, false);
        setmarker(:fontSize, idPanel, 1.5);
        setmarker(:flushText, idPanel, 0);
        setmarker(:pos, idPanel, berthaX, berthaY - 5);

        var infoButton = playerButton(berthaX + 5, berthaY, 3, 2, @clientUnit);
        print(infoButton != 0 ? highlightColor : textColor);
        print("[ ? ]");
        makemarker(:text, idInfo, 0, 0, false);
        setmarker(:fontSize, idInfo, 2.5);
        setmarker(:flushText, idInfo, 0);
        setmarker(:pos, idInfo, berthaX + 5, berthaY + 0.5);

        noinit opened;
        if infoButton >= 1  then

            print(titleColor, "Info\n");
            print(textColor, ": Triple Shot\n");
            print(textColor,": Anticreep Payload\n");
            print(textColor, "Not affected\nby overdrive");

            makemarker(:text, idInfo2, 0, 0, false);
            setmarker(:fontSize, idInfo2, 1.5);
            setmarker(:flushText, idInfo2, 0);
            setmarker(:pos, idInfo2, berthaX + 13, berthaY + 2);

        else
            setmarker(:remove, idInfo2);
        end;



    else

        setmarker(:remove, idManualAim);
        setmarker(:remove, idAutoAim);
        setmarker(:remove, idVault);
        setmarker(:remove, idPanel);
        setmarker(:remove, idInfo);
        setmarker(:remove, idInfo2);

    end;

    // Position



    setmarker(:pos, idBertha1, berthaBarrelX, berthaBarrelY);
    setmarker(:rotation, idBertha1, angle + 90);
    setmarker(:rotation, idBertha2, angle + 90);

    // Aim Marker
    if (manualAimButton == 1 || autoAimButton == 1 || (aimingPlayer != null && aimingPlayer != "auto")) && targetX != null then

        var offSetX = berthaX - cos(targetAngle) * 8;
        var offSetY = berthaY - sin(targetAngle) * 8;
        var aimColor = packcolor(255/255, 100/255, 100/255, 1);
        lastAim = @second;

        makemarker(:line, idAim1, 0, 0, false);
        setmarker(:pos, idAim1, offSetX, offSetY);
        setmarker(:endPos, idAim1, targetX, targetY);
        setmarker(:drawLayer, idAim1, 100);
        setmarker(:stroke, idAim1, 2);
        setmarker(:color, idAim1, aimColor);

        makemarker(:shape, idAim2, 0, 0, false);
        setmarker(:pos, idAim2, offSetX, offSetY);
        setmarker(:shape, idAim2, 4, 1, 0);
        setmarker(:drawLayer, idAim2, 100);
        setmarker(:color, idAim2, aimColor);

        makemarker(:shape, idAim3, 0, 0, false);
        setmarker(:pos, idAim3, targetX, targetY);
        setmarker(:shape, idAim3, 4, 1, 0);
        setmarker(:drawLayer, idAim3, 100);
        setmarker(:color, idAim3, aimColor);

        if manualAimTimeoutClient < 9 && aimingPlayer != null && aimingPlayer != "auto" then
            print("[#ff6363]Timeout: ", floor(manualAimTimeoutClient));
            tooltipMarker(idAimTimeout, targetX, targetY, 2);
        else
            setmarker(:remove, idAimTimeout);
        end;

    else
        setmarker(:remove, idAimTimeout);
        var timeElapsed = @second - lastAim;
        if timeElapsed > 0.5 then
            setmarker(:remove, idAim1);
            setmarker(:remove, idAim2);
            setmarker(:remove, idAim3);
        end;
        var alpha = clamp(1 - (timeElapsed / 0.5), 0, 1);
        var aimColor = packcolor(255/255, 100/255, 100/255, alpha);
        setmarker(:color, idAim1, aimColor);
        setmarker(:color, idAim2, aimColor);
        setmarker(:color, idAim3, aimColor);
    end;

end;


inline void initialize()

    berthaBarrelX = berthaX;
    berthaBarrelY = berthaY;

    makemarker(:texture, idBertha1, 0, 0, 0);
    makemarker(:texture, idBertha2, 0, 0, 0);
    makemarker(:texture, idShadow, 0, 0, 0);
    makemarker(:texture, idLeg1, 0, 0, 0);
    makemarker(:texture, idLeg2, 0, 0, 0);
    makemarker(:texture, idLeg3, 0, 0, 0);
    makemarker(:texture, idLeg4, 0, 0, 0);

    setmarker(:texture, idBertha1, 0, "titan-barrel-outline");
    setmarker(:texture, idBertha2, 0, "titan-outline");
    setmarker(:texture, idShadow, 0, "circle-shadow");
    setmarker(:texture, idLeg1, 0, "titan-side-l-outline");
    setmarker(:texture, idLeg2, 0, "titan-side-l-outline");
    setmarker(:texture, idLeg3, 0, "titan-side-r-outline");
    setmarker(:texture, idLeg4, 0, "titan-side-r-outline");

    setmarker(:textureSize, idBertha1, 3, 7);
    setmarker(:textureSize, idBertha2, 4, 8);
    setmarker(:textureSize, idShadow, 8, 8);
    setmarker(:textureSize, idLeg1, 6, 6);
    setmarker(:textureSize, idLeg2, 6, -6);
    setmarker(:textureSize, idLeg3, -6, 6);
    setmarker(:textureSize, idLeg4, -6, -6);

    setmarker(:rotation, idLeg1, 45);
    setmarker(:rotation, idLeg2, -45);
    setmarker(:rotation, idLeg3, -45);
    setmarker(:rotation, idLeg4, 45);

    setmarker(:color, idShadow, %000000a7);

    setmarker(:drawLayer, idBertha1, 55);
    setmarker(:drawLayer, idBertha2, 54.9);
    setmarker(:drawLayer, idShadow, 54);
    setmarker(:drawLayer, idLeg1, 54.1);
    setmarker(:drawLayer, idLeg2, 54.1);
    setmarker(:drawLayer, idLeg3, 54.1);
    setmarker(:drawLayer, idLeg4, 54.1);

    setmarker(:pos, idBertha1, berthaX, berthaY);
    setmarker(:pos, idBertha2, berthaX, berthaY);
    setmarker(:pos, idShadow, berthaX, berthaY -1 );
    setmarker(:pos, idLeg1, berthaX - 3, berthaY);
    setmarker(:pos, idLeg2, berthaX - 3, berthaY - 0.5);
    setmarker(:pos, idLeg3, berthaX + 3, berthaY);
    setmarker(:pos, idLeg4, berthaX + 3, berthaY - 0.5);

end;

void tripleShot(startX, startY, phase)

    var r = -10;

    var x1 = targetX + r * cos(targetAngle);
    var y1 = targetY + r * sin(targetAngle);

    var x2 = targetX + r * cos(targetAngle + 120);
    var y2 = targetY + r * sin(targetAngle + 120);

    var x3 = targetX + r * cos(targetAngle + 240);
    var y3 = targetY + r * sin(targetAngle + 240);

    async(processor1.bullet(startX, startY, x1, y1, phase));
    async(processor2.bullet(startX, startY, x2, y2, phase));
    async(processor3.bullet(startX, startY, x3, y3, phase));

end;

inline def booster(in resource, in ammoCost, ref syncVar)
    if vault.sensor(resource) >ammoCost then
        vault.setprop(resource, vault.sensor(resource) - ammoCost);
        syncVar = vault.sensor(resource);
        sync(syncVar);
        return 1;
    end;
end;